<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Titolo del post del blog">
    <title>Breaking Caesar's Cypher</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: "Helvetica", Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #fafafa;
            color: #333;
        }

        header {
            background-color: #222;
            color: white;
            padding: 1.5rem 0;
            text-align: center;
        }

        main {
            max-width: 800px;
            margin: 2rem auto;
            background: white;
            padding: 2rem;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            border-radius: 10px;
        }

        article h1 {
            color: #111;
            margin-bottom: 0.5rem;
        }
.table-container {
      display: flex;
      justify-content: center;
      margin-top: 40px;
    }

    table {
      border-collapse: collapse;
      width: 60%;
      text-align: center;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      background-color: white;
    }

    th, td {
      border: 1px solid #ddd;
      padding: 10px;
    }

    thead {
      background-color: #4CAF50;
      color: white;
    }

    tr:nth-child(even) {
      background-color: #f2f2f2;
    }

    tr:hover {
      background-color: #e0f7e0;
    }
        .post-meta {
            color: #777;
            font-size: 0.9rem;
            margin-bottom: 2rem;
        }

        article img {
            width: 100%;
            border-radius: 10px;
            margin: 1rem 0;
        }

        footer {
            text-align: center;
            padding: 1rem;
            background-color: #222;
            color: white;
            font-size: 0.9rem;
        }

        .riquadro-testo {
            width: 400px;
            padding: 20px;
            margin: 40px auto;
            background-color: #f8f9fa;
            border: 2px solid #ccc;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            font-family: Arial, sans-serif;
            font-size: 16px;
            color: #333;
            line-height: 1.5;
            overflow-y: auto;
            max-height: 200px;
        }

        /* Added styles for classes referenced in the HTML */
        .wrap {
            margin-top: 20px;
        }
        .panel {
            background: #f8fafc;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
        }

        .col {
            flex: 0.85;
        }

        .warning {
            background: #fff8e6;
            padding: 12px;
            border-left: 4px solid #f59e0b;
            border-radius: 6px;
            margin: 12px 0;
        }
    </style>
</head>
<body>

    <header>
        <h1>Homework 3</h1>
    </header>

    <main>
       <article>
  <section>
    <h2>Breaking the RSA cypher</h2>

    <div class="warning">
      <strong>Warning:</strong> the discussion that follows is conceptual and focuses on why insecure parameter choices make cryptosystems vulnerable. It does not provide operational instructions for attacking real systems. Always follow laws and responsible disclosure practices.
    </div>

    <p>RSA security relies on the mathematical difficulty of factoring the modulus <code>N = p &middot; q</code> when <code>p</code> and <code>q</code> are large secret primes. If <code>p</code> and <code>q</code> are chosen too small, two broad failure modes appear:</p>

    <ul>
      <li><strong>Factorization becomes feasible:</strong> small primes reduce the search space, and factoring <code>N</code> can be done with modest computational effort.</li>
      <li><strong>Searchable space of candidate plaintexts:</strong> when the key or plaintext space is small, an attacker can enumerate many candidate decryptions. Among those candidates, the correct plaintext often exhibits natural-language statistical properties (letter frequencies, common digrams/trigrams, word patterns) that make it distinguishable.</li>
    </ul>

    <p>In practice, a statistical recognition strategy works like this (high-level): an attacker that obtains many candidate decryptions scores each candidate for how closely it matches expected language statistics (for example English letter frequencies, expected bigram counts, or language models). The candidate with the best statistical fit is considered the most plausible plaintext. This is a recognition problem rather than a purely mathematical factorization: it exploits the fact that real plaintexts are not uniform random bytes but contain structure.</p>

    <p>Important caveats:</p>
    <ul>
      <li>This method assumes the attacker can produce many candidate decryptions (small keyspace, weak padding, or other weaknesses that allow enumeration).</li>
      <li>Modern secure deployments mitigate such attacks by using long keys (e.g., 2048+ bit RSA) and secure padding schemes (OAEP) and by combining encryption with integrity (e.g., authenticated encryption or MACs).</li>
    </ul>

    <h3>Defensive recommendations (best practices)</h3>
    <ul>
      <li>Use strong, modern key sizes and algorithms. For RSA, current best practice is to favor alternatives (e.g., elliptic-curve-based schemes) or at minimum use RSA with 2048+ bit moduli if required by legacy systems.</li>
      <li>Always use secure padding (OAEP for RSA encryption) and authenticated modes for symmetric encryption (e.g., AES-GCM) to prevent an attacker from reliably testing candidate plaintexts.</li>
      <li>Compress or encode plaintexts before encryption when appropriate: compression or binary formats reduce predictable plaintext structure and make statistical recognition harder.</li>
      <li>Rotate keys and apply defense-in-depth: monitoring, rate-limiting, and careful handling of error messages reduce the usefulness of brute-force or enumeration approaches.</li>
    </ul>

    <!-- BEGIN Alice RSA demo -->
    <div class="alice-demo" style="max-width:800px;margin:18px auto;padding:16px;background:#fff;border-radius:8px;box-shadow:0 6px 18px rgba(2,6,23,0.06);">
      <h3>Alice excerpt (public domain)</h3>

      <div id="aliceText" style="padding:12px;background:#f8fafc;border-radius:6px;line-height:1.5;">
        Alice was beginning to get very tired of sitting by her sister on the bank, and of having nothing to do:
        once or twice she had peeped into the book her sister was reading, but it had no pictures or conversations in it,
        'and what is the use of a book,' thought Alice 'without pictures or conversation?'
      </div>
	<button id="encryptBtn" style="margin-top:12px;padding:8px 16px;background:#3b82f6;color:white;border:none;border-radius:4px;cursor:pointer;" onclick= "encryptTextRSA(document.getElementById('aliceText').innerText,e,n);">Encrypt</button>
      <div class="col" style="flex:0.85">
        <div class="panel">
          <strong>Ciphertext (array of numbers)</strong>
	<div id="cipherText"></div>
          <p style="margin-top:8px; font-size:14px; color:#334155">
            The ciphertext is shown as an array of integers. Each integer is the result of encrypting a single character code with
            <code>c = m^e mod n</code>. This simple packing is used here for clarity.
          </p>
	
        </div>
	<div>
	  <strong>Note:</strong> To demonstrate the statistical recognition attack, we need to implement a decryption function that tries all possible keys (given the small key size) and scores each resulting plaintext based on letter frequency analysis. The plaintext with the highest score would be selected as the most likely correct decryption. We of course know the public key, so we can search for a feasible private key and generate many candidates plaintext and score them.
	</div>
	<button onclick='generateCandidatePlaintexts();'>Generate Candidate Plaintexts</button>
	
	 </div> <!-- end .col -->
    </div> <!-- end .alice-demo -->
    <!-- END Alice RSA demo -->
  </section>

  <section>
    <h2>2) How this demonstrates recognition by letter frequencies</h2>
    <p>In the demo above, an attacker who can try candidate decryptions (for example because the keyspace is small) can use a letter-frequency score to pick the most plausible plaintext among many candidates. The chart makes it visible: the decrypted, correct plaintext shows the characteristic non-uniform distribution of letters (e.g., more 'e', 't', 'a' in English), whereas random bytes look uniform.</p>
    <p>Again: this is a recognition strategy and not a direct factoring algorithm — it helps identify correct plaintexts when enumeration is possible.</p>
  </section>
    <div> Once we calculate the chi squared scores for each candidate plaintext, we can identify the most likely correct decryption by selecting the one with the lowest score. This approach leverages the statistical properties of natural language to distinguish the correct plaintext from incorrect candidates. In my example, the candidate plaintext generated using d=43 produced the lowest chi squared score, indicating it is the most likely correct decryption of the ciphertext. This demonstrates how statistical analysis can be effectively used to break weak RSA encryption by recognizing patterns in the decrypted text.
    </div>
                <div class="table-container">
    <table id="chiTable">
      <thead>
        <tr>
          <th>Indice</th>
          <th>Chi Score</th>
        </tr>
      </thead>
      <tbody>
        <!-- Le righe verranno generate qui -->
      </tbody>
    </table>
  </div>

</article>

    </main>

    <footer>
        &copy; 2025 — Your Blog Name
    </footer>



<script>
        // choose prime numbers
        let p=11,q=13;
	let ciphertext = [];
        let privateKey, publicKey, n, phi;
	const ENG_FREQ = {
  A:0.082, B:0.015, C:0.028, D:0.043, E:0.13, F:0.022, G:0.02, H:0.061,
  I:0.07, J:0.002, K:0.008, L:0.04, M:0.024, N:0.067, O:0.075, P:0.019,
  Q:0.001, R:0.06, S:0.063, T:0.091, U:0.028, V:0.01, W:0.023, X:0.001,
  Y:0.02, Z:0.0007
};
	let candidatePlaintexts = [];
        function gcd(a, b) {
            if (b === 0) return a;
            return gcd(b, a % b);
        }

        n = p * q; // modulus
        phi = (p - 1) * (q - 1); // totient

        console.log(`Chosen p: ${p}, q: ${q}`);
        console.log(`Calculated n: ${n}, phi: ${phi}`);
        let e = 7; // public exponent

        // Ensure that e is coprime to phi and n
        while (gcd(e, phi) !== 1) {
            e += 2; // increment e to find a coprime
        }
        console.log(`Chosen e: ${e}`);

        // Calculate d, the modular multiplicative inverse of e mod phi
        function modInverse(e, phi) {
            let m0 = phi, t, q;
            let x0 = 0, x1 = 1;

            if (phi === 1) return 0;

            while (e > 1) {
                q = Math.floor(e / phi);
                t = phi;

                phi = e % phi;
                e = t;
                t = x0;

                x0 = x1 - q * x0;
                x1 = t;
            }

            if (x1 < 0) x1 += m0;

            return x1;
        }

        let d = modInverse(e, phi); // private exponent


        console.log(`Public Key: (e: ${e}, n: ${n})`);
        console.log(`Private Key: (d: ${d}, n: ${n})`);

	const outputDiv = document.getElementById('cipherText');

        function encryptTextRSA(plaintext, e, n) {
        ciphertext = [];
	console.log("Encrypting text with RSA...");
	console.log('plaintext:', plaintext);
	outputDiv.textContent = '';
            for (let char of plaintext) {
                let m = char.charCodeAt(0);
                let c = BigInt(m) ** BigInt(e) % BigInt(n);
                ciphertext.push(c);
            }

	outputDiv.textContent = ciphertext.map(x => x.toString()).join(' ');
            return ciphertext;
        }

        function decryptTextRSA(ciphertext, d, n) {
            let plaintext = '';
            for (let c of ciphertext) {
                let m = BigInt(c) ** BigInt(d) % BigInt(n);
                plaintext += String.fromCharCode(Number(m));
            }
            return plaintext;
        }    

	function generateCandidatePlaintexts() {
            let scoreDictionary = {};
	    console.log("Generating candidate plaintexts by trying all possible private keys...");
	    candidatePlaintexts = [];
	    for (let possibleD = 1; possibleD < n; possibleD++) {
		let candidatePlaintext = decryptTextRSA(ciphertext, possibleD, n);
		candidatePlaintexts.push({d: possibleD, text: candidatePlaintext});
                scorePlaintext(candidatePlaintext,possibleD);
                scoreDictionary[possibleD] = scorePlaintext(candidatePlaintext,possibleD);
                if (possibleD === 43) {
                    console.log(`Candidate plaintext for d=${possibleD}: ${candidatePlaintext}`);
                }
	    }
	    console.log(`Generated dictionary of scores for candidate plaintexts:`,scoreDictionary);
            // Sort the scoreDictionary by score values in ascending order
            // ottieni array ordinato per score crescente
            const top5Entries = Object.entries(scoreDictionary)
              .sort((a, b) => a[1] - b[1])
              .slice(0, 5);

            console.log('Top5 (array):', top5Entries);
            // stampa ordinata correttamente
            for (const [key, score] of top5Entries) {
              console.log(`${key}: ${score}`);
            }

            const tbody = document.querySelector("#chiTable tbody");

    // Genera una riga per ogni coppia chiave-valore
            for (const [indice, score] of Object.entries(top5Entries)) {
      const row = document.createElement("tr");
      row.innerHTML = `
        <td>${score[0]}</td>
        <td>${score[1]}</td>
      `;
      tbody.appendChild(row);
    }

	
	}

        function scorePlaintext(plaintext,index) {
            let score = 0;
            let letterCounts = {};
            let totalLetters = 0;

            for (let char of plaintext.toUpperCase()) {
                if (char >= 'A' && char <= 'Z') {
                    letterCounts[char] = (letterCounts[char] || 0) + 1;
                    totalLetters++;
                }
            }

            for (let letter in ENG_FREQ) {
                let observedFreq = (letterCounts[letter] || 0) / totalLetters;
                score += Math.abs(observedFreq - ENG_FREQ[letter]);
            }
            console.log(`Score for plaintext "${index}": ${score}`);
            return score;
        }





</script>

</body>
</html>


